{
    "parametrized_description": "A breakfast joint produces NumSandwichTypes different types of sandwiches using NumIngredients different ingredients. The amount of each ingredient required for each sandwich type is specified by Required. The total availability of each ingredient is given by TotalAvailable. The profit earned per unit of each sandwich type is defined by ProfitPerSandwich. The objective is to determine the number of each sandwich type to produce in order to maximize total profit.",
    "keywords": [
        "N.A."
    ],
    "parameters": {
        "NumSandwichTypes": {
            "description": "Number of different sandwich types",
            "shape": []
        },
        "NumIngredients": {
            "description": "Number of different ingredients",
            "shape": []
        },
        "Required": {
            "description": "Amount of ingredient j required to produce one unit of sandwich i",
            "shape": [
                "NumIngredients",
                "NumSandwichTypes"
            ]
        },
        "TotalAvailable": {
            "description": "Total availability of ingredient j",
            "shape": [
                "NumIngredients"
            ]
        },
        "ProfitPerSandwich": {
            "description": "Profit per unit of sandwich i",
            "shape": [
                "NumSandwichTypes"
            ]
        }
    },
    "variables": {
        "NumSandwiches": {
            "description": "The number of sandwiches to produce for each sandwich type",
            "type": "continuous",
            "shape": [
                "NumSandwichTypes"
            ]
        }
    },
    "constraints": [
        {
            "description": "The total usage of eggs for producing regular and special sandwiches does not exceed the total available eggs.",
            "formulation": "\\sum_{i=1}^{NumSandwichTypes} Required_{eggs,i} \\cdot NumSandwiches_i \\leq TotalAvailable_{eggs}",
            "code": {
                "gurobipy": "model.addConstr(quicksum(Required[0, i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[0])"
            }
        },
        {
            "description": "The total usage of bacon for producing regular and special sandwiches does not exceed the total available bacon.",
            "formulation": "\\sum_{i=1}^{\\text{NumSandwichTypes}} \\text{Required}_{j,i} \\cdot \\text{NumSandwiches}_i \\leq \\text{TotalAvailable}_j",
            "code": {
                "gurobipy": "model.addConstr(quicksum(Required[j, i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[j])"
            }
        },
        {
            "description": "The number of regular and special sandwiches produced is non-negative.",
            "formulation": "NumSandwiches \\geq 0",
            "code": {
                "gurobipy": "model.addConstrs((NumSandwiches[i] >= 0 for i in range(NumSandwichTypes)), 'NumSandwichesNonNegative')"
            }
        }
    ],
    "objective": {
        "description": "The total profit is the sum of the profit per sandwich type multiplied by the number of sandwiches produced. The objective is to maximize the total profit.",
        "formulation": "Max \\sum_{i=1}^{NumSandwichTypes} ProfitPerSandwich_{i} \\times NumSandwiches_{i}",
        "code": {
            "gurobipy": "model.setObjective(quicksum(NumSandwiches[i] * ProfitPerSandwich[i] for i in range(NumSandwichTypes)), GRB.MAXIMIZE)"
        }
    }
}