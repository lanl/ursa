project: multi_repo_example

models:
  choices:
    - openai:gpt-5.2
    - openai:gpt-5.2-mini
    - openai:gpt-5.2-codex
  default: openai:gpt-5.2-mini
  planner: openai:gpt-5.2      # model for planning; falls back to default
  executor: openai:gpt-5.2     # model for execution; falls back to default

planner:
  reflection_steps: 4
  research:
    # GitHub issues/PRs are fetched automatically from repo URLs (requires gh CLI).
    # github:
    #   enabled: true        # default: true -- set false to skip
    #   max_issues: 10       # recent issues per repo (default 10)
    #   max_prs: 10          # recent PRs per repo (default 10)
    #
    # Optional additional web search queries to seed planning context:
    # queries:
    #   - "recent issues for repo_a"

execution:
  max_parallel: 5
  recursion_limit: 2000
  resume: false
  status_interval_sec: 5
  max_check_retries: 2  # retries per step when checks fail (0 = no retries)
  step_timeout_sec: 0   # max seconds per agent step; 0 = no limit

repos:
  - name: boot-service
    url: https://github.com/openchami/boot-service.git
    branch: main
    checkout: true
    language: go
    description: "Fabrica-generated Go microservice for HPC node boot management (boot configs, boot scripts, boot parameters)"
    checks:
      - go test ./...

  - name: metadata-service
    url: https://github.com/openchami/metadata-service.git
    branch: main
    checkout: true
    language: go
    description: "Fabrica-generated Go microservice for HPC node metadata (node metadata records, group metadata)"
    checks:
      - go test ./...

  - name: smd
    url: https://github.com/openchami/smd.git
    branch: main
    checkout: true
    language: go
    description: "Legacy HPC state management service; must remain backwards compatible"
    checks:
      - go test ./...

  - name: tokensmith
    url: https://github.com/openchami/tokensmith.git
    branch: main
    checkout: true
    language: go
    description: "Shared Go library for JWT authentication and Casbin-based authorization middleware"
    checks:
      - go test ./...

  - name: fabrica
    url: https://github.com/openchami/fabrica.git
    branch: main
    checkout: true
    language: go
    description: "Code generation tool that produces HTTP server scaffolding for OpenCHAMI services; read-only reference"
    checks:
      - go test ./...

  

problem: |
  TITLE: Implement consistent Casbin-based authorization across OpenCHAMI services

  CONTEXT:
  boot-service and metadata-service are fabrica-generated Go microservices.
  Fabrica generates the HTTP server scaffolding and route registration;
  hand-written middleware and business logic live alongside generated code
  in each service. Both services use tokensmith's JWT middleware for
  authentication. tokensmith can issue JWTs today, but the long-term plan
  is to use an external IdP (HashiCorp Vault, Keycloak); tokensmith should
  remain the shared library for JWT validation and Casbin-based
  authorization, with JWT issuing preserved as a fallback.

  Casbin-based authorization exists in tokensmith (see GitHub issue #5 and
  PR #6) but is incomplete and undocumented. Neither boot-service nor
  metadata-service currently enforce authorization beyond authentication.

  smd is a legacy service that must remain fully backwards compatible. It
  should be updated to optionally leverage tokensmith for authorization
  checks when enabled via a feature flag, but default behavior must be
  unchanged (authorization disabled by default).

  AUTHORIZATION MODEL:
  Define and implement RBAC with at minimum these roles:
    - admin: full CRUD on all resources across all services
    - operator: read and write boot configs, metadata, and SMD state; no delete
    - viewer: read-only access to all resources
    - service: service-to-service calls (e.g. boot-service reading metadata)

  Protected resources by service:
    - boot-service: boot configurations, boot scripts, boot parameters
    - metadata-service: node metadata records, group metadata
    - smd: hardware state, component data (only when feature flag is enabled)

  TASKS:
  1. Review and complete the Casbin integration in tokensmith. Ensure the
     middleware exposes a reusable authorization function that services can
     call with (subject, resource, action) and get an allow/deny decision.
     Build on the existing work from issue #5 and PR #6. Add comprehensive
     tests and documentation.
  2. Review how boot-service and metadata-service currently consume
     tokensmith middleware. Identify what changes are needed to add
     authorization.
  3. Integrate tokensmith authorization middleware into boot-service,
     enforcing the RBAC model above on all routes.
  4. Integrate tokensmith authorization middleware into metadata-service,
     enforcing the same RBAC model.
  5. Add optional authorization to smd behind a feature flag (e.g.
     environment variable or config option). When disabled (the default),
     smd behaves exactly as it does today. When enabled, smd uses
     tokensmith middleware to enforce the RBAC model on its endpoints.
     Ensure full backwards compatibility.
  6. Add integration tests demonstrating HPC scenarios: a node
     administrator boots a compute node, a monitoring service queries
     metadata read-only, an operator updates boot parameters, an
     unauthorized user is denied access.

  CONSTRAINTS:
  - Do not modify fabrica unless absolutely necessary. If changes to
    fabrica are required, document the reasoning and keep them minimal.
  - smd default behavior must be unchanged; authorization is opt-in only.
  - All existing tests must continue to pass.
  - Use make targets where available to run tests.
  - Commit each logical step separately with clear, descriptive messages.
  - Do not push to remote repositories.
